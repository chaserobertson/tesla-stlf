---
title: "intra_day"
output: html_document
date: "2023-04-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
data_path <- "../data/merged_interpolated.csv"
df <- read.csv(data_path)
head(df)
```

Subset to just the relevant variables for intra-day models.

```{r}
df2 <- df[,c('datetime', 'tempc', 'net_load')]
head(df2)
```

Australian Central Standard Time assumed to be the read-in default - consider as UTC to avoid DST adjustments.

```{r}
df2$acst <- as.POSIXct(df2$datetime, format="%F %T", tz="UTC")
head(df2)
```

Create DST adjusted timestamp via correct timezone and offset.

```{r}
df2$acdt <- as.POSIXct(paste(df2$datetime, "+1030"), format="%F %T %z", tz="Australia/South")
head(df2)
```

Demonstrate standard / daylight time differences.

```{r}
head(df2[as.character(df2$acst) != as.character(df2$acdt),])
```

Create standardised Time variable to fit intra-day Model 1 requirements.

```{r}
dt.lt <- as.POSIXlt(df2$acst)
# time normalised to [0, 1) via proportion of 1440 minutes per day
df2$Time <- (dt.lt$hour*60 + dt.lt$min) / 1440
summary(df2$Time)
```

Additionally require DST adjusted version of standardised Time field.

```{r}
dst.lt <- as.POSIXlt(df2$acdt)
df2$DST <- ((dst.lt$hour*60 + dst.lt$min) + 60*(dst.lt$isdst!=0)) / 1440
summary(df2$DST)
```

Max standardised DST should be 2 observations ahead, out of 48.

```{r}
c(max(df2$DST) - max(df2$Time), 2 / 48)
```

Create standardised time of the Year with range [0,1), 0 being first observation of the year and 1 being just after the final observation (by standard time).

```{r}
df2$year <- (dst.lt$yday + df2$Time) / 366
summary(df2$year)
```

Choose arbitrary train / test split, where test days are every tenth day in a year.

```{r}
test_ind <- as.POSIXlt(df2$acst)$yday %% 10 == 0
```

Subset to just those variables necessary for modeling.

```{r}
df3 <- cbind(df2[,c('net_load', 'DST', 'tempc', 'year')])
head(df3)
```

Execute train/test split.

```{r}
train <- df3[!test_ind,]
test <- df3[test_ind,]
c(dim(df3), dim(train), dim(test))
```

Try fit Model 5.

TODO figure out how to implement these with mgcv correctly

- s(DST) as cyclic cubic regression spline
- w(DST) as piecewise continuous sinusoidal function
- h(Temp*w(DST)) as...?
- k(Year) as non-periodic spline

```{r}
library(mgcv)

model5 <- gam(net_load ~ s(DST, bs="cc") + s(tempc * s(DST)) + s(year), data=train)
summary(model5)
```

